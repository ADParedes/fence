import bcrypt

from authlib.common.security import generate_token
from authlib.common.urls import add_params_to_uri
from authlib.specs.rfc6749.errors import (
    AccessDeniedError,
    InvalidClientError,
    InvalidRequestError,
    InvalidScopeError,
    UnauthorizedClientError,
)
from authlib.specs.rfc6749.grants import (
    AuthorizationCodeGrant as _AuthorizationCodeGrant,
    RefreshTokenGrant as _RefreshTokenGrant,
)
import flask

import fence
from fence.jwt.blacklist import is_token_blacklisted
from fence.jwt.errors import JWTError
import fence.jwt.validate
from fence.models import AuthorizationCode


class AuthorizationCodeGrant(_AuthorizationCodeGrant):

    def __init__(self, uri, params, headers, client_model, token_generator):
        super(AuthorizationCodeGrant, self).__init__(
            uri, params, headers, client_model, token_generator
        )

    def create_authorization_code(self, client, user, **kwargs):
        code = AuthorizationCode(
            code=generate_token(50),
            client_id=client.client_id,
            redirect_uri=kwargs.get('redirect_uri', ''),
            scope=kwargs.get('scope', ''),
            user_id=user.id,
        )

        with flask.current_app.db.session as session:
            session.add(code)
            session.commit()

        return code.code

    def parse_authorization_code(self, code, client):
        with flask.current_app.db.session as session:
            code = (
                session.query(AuthorizationCode)
                .filter_by(code=code, client_id=client.client_id)
                .first()
            )
        if not code or code.is_expired():
            return None
        return code

    def delete_authorization_code(self, authorization_code):
        with flask.current_app.db.session as session:
            session.delete(authorization_code)
            session.commit()

    def create_access_token(self, token, client, authorization_code):
        pass

    def authenticate_client(self):
        """Parse the authenticated client.

        For example, the client makes the following HTTP request using TLS:

        .. code-block:: http

            POST /token HTTP/1.1
            Host: server.example.com
            Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
            Content-Type: application/x-www-form-urlencoded

            grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
            &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb

        To authenticate client with other means, re-implement this method in
        subclass.

        :return: client
        """
        client_params = self.parse_basic_auth_header()
        if client_params:
            # authenticate the client if client authentication is included
            client_id, client_secret = client_params
            client = self.get_and_validate_client(client_id)
            # Client secrets are stored as hash.
            hashed = client.client_secret
            if bcrypt.hashpw(client_secret, hashed) != hashed:
                raise InvalidClientError(uri=self.uri)

            return client

        # require client authentication for confidential clients or for any
        # client that was issued client credentials (or with other
        # authentication requirements)
        client_id = self.params.get('client_id')
        client = self.get_and_validate_client(client_id)
        if client.check_client_type('confidential') or client.client_secret:
            raise UnauthorizedClientError(uri=self.uri)

        return client

    def create_authorization_response(self, grant_user):
        """
        If the resource owner grants the access request, the authorization
        server issues an authorization code and delivers it to the client by
        adding the following parameters to the query component of the
        redirection URI using the "application/x-www-form-urlencoded" format.
        Per `Section 4.1.2`_.

        code
            REQUIRED.  The authorization code generated by the
            authorization server. The authorization code MUST expire
            shortly after it is issued to mitigate the risk of leaks. A
            maximum authorization code lifetime of 10 minutes is
            RECOMMENDED. The client MUST NOT use the authorization code
            more than once. If an authorization code is used more than
            once, the authorization server MUST deny the request and SHOULD
            revoke (when possible) all tokens previously issued based on
            that authorization code.  The authorization code is bound to
            the client identifier and redirection URI.
        state
            REQUIRED if the "state" parameter was present in the client
            authorization request.  The exact value received from the
            client.

        For example, the authorization server redirects the user-agent by
        sending the following HTTP response.

        .. code-block:: http

            HTTP/1.1 302 Found
            Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
                   &state=xyz

        .. _`Section 4.1.2`: http://tools.ietf.org/html/rfc6749#section-4.1.2

        :param grant_user: pass user model if resource owner granted the
            request, otherwise pass None.
        :returns: (status_code, body, headers)
        """
        if grant_user:
            # ``self.params`` is a werkzeug ``ImmutableMultiDict`` which will
            # cast its values into lists when implicitly to a dictionary (as
            # with the ** syntax), so first turn it into a normal dictionary.
            code = self.create_authorization_code(
                self.client, grant_user, **self.params.to_dict()
            )
            params = [('code', code)]
            if self.state:
                params.append(('state', self.state))
        else:
            error = AccessDeniedError(state=self.state, uri=self.uri)
            params = error.get_body()

        uri = add_params_to_uri(self.redirect_uri, params)
        headers = [('Location', uri)]
        return 302, '', headers


class RefreshTokenGrant(_RefreshTokenGrant):

    def authenticate_refresh_token(self, refresh_token):
        try:
            if is_token_blacklisted(refresh_token):
                return
        except JWTError:
            return
        return fence.jwt.validate.validate_refresh_token(refresh_token)

    def create_access_token(self, token, client, authenticated_token):
        return token

    def authenticate_client(self):
        client_params = self.parse_basic_auth_header()
        if not client_params:
            raise InvalidClientError(uri=self.uri)

        client_id, client_secret = client_params
        client = self.get_and_validate_client(client_id)

        hashed = client.client_secret
        if bcrypt.hashpw(client_secret, hashed) != hashed:
            raise InvalidClientError(uri=self.uri)

        return client

    def validate_access_token_request(self):
        """
        From authlib:

        If the authorization server issued a refresh token to the client, the
        client makes a refresh request to the token endpoint by adding the
        following parameters using the "application/x-www-form-urlencoded"
        format per Appendix B with a character encoding of UTF-8 in the HTTP
        request entity-body, per Section 6:

        grant_type
            REQUIRED.  Value MUST be set to "refresh_token".

        refresh_token
            REQUIRED.  The refresh token issued to the client.

        scope
            OPTIONAL.  The scope of the access request as described by
            Section 3.3.  The requested scope MUST NOT include any scope
            not originally granted by the resource owner, and if omitted is
            treated as equal to the scope originally granted by the
            resource owner.


        For example, the client makes the following HTTP request using
        transport-layer security (with extra line breaks for display purposes
        only):

        .. code-block:: http

            POST /token HTTP/1.1
            Host: server.example.com
            Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
            Content-Type: application/x-www-form-urlencoded

            grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
        """
        # From authlib:
        #
        #     Require client authentication for confidential clients or for any
        #     client that was issued client credentials (or with other
        #     authentication requirements).
        client = self.authenticate_client()
        if not client.check_client_type('confidential'):
            raise UnauthorizedClientError(uri=self.uri)
        if not client.check_grant_type(self.GRANT_TYPE):
            raise UnauthorizedClientError(uri=self.uri)
        self._authenticated_client = client

        # Get refresh token from request.
        refresh_token = self.params.get('refresh_token')
        if refresh_token is None:
            raise InvalidRequestError(
                'Missing "refresh_token" in request.',
                uri=self.uri,
            )
        # Validate the refresh token.
        token = self.authenticate_refresh_token(refresh_token)
        if not token:
            raise InvalidRequestError(
                'Invalid "refresh_token" in request.',
                uri=self.uri,
            )
        # Compare the requested scope (which will be stored as audiences in the
        # access token) against the ``access_aud`` field in the refresh token
        # (which stores the audiences allowed to be in the access token).
        scope = self.params.get('scope')
        if scope:
            access_aud = token.get('access_aud')
            if not access_aud:
                raise InvalidScopeError(uri=self.uri)
            access_aud = set(access_aud)
            if not access_aud.issuperset(set(scope)):
                raise InvalidScopeError(uri=self.uri)

        self._authenticated_token = token

    def create_access_token_response(self):
        scope = self.params.get('scope')
        if not scope:
            scope = self._authenticated_token['access_aud']
        token = self.token_generator(
            self._authenticated_client, self.GRANT_TYPE, scope=scope,
        )
        self.create_access_token(
            token, self._authenticated_client, self._authenticated_token
        )
        return 200, token, self.TOKEN_RESPONSE_HEADER
