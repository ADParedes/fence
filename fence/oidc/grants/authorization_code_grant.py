import bcrypt

from authlib.common.security import generate_token
from authlib.common.urls import add_params_to_uri
from authlib.specs.rfc6749.errors import (
    AccessDeniedError,
    InvalidClientError,
    UnauthorizedClientError,
)
from authlib.specs.rfc6749.grants import (
    AuthorizationCodeGrant as AuthlibAuthorizationCodeGrant
)
import flask

from fence.models import AuthorizationCode


class AuthorizationCodeGrant(AuthlibAuthorizationCodeGrant):

    def __init__(self, uri, params, headers, client_model, token_generator):
        super(AuthorizationCodeGrant, self).__init__(
            uri, params, headers, client_model, token_generator
        )

    def create_authorization_code(self, client, user, **kwargs):
        code = AuthorizationCode(
            code=generate_token(50),
            client_id=client.client_id,
            redirect_uri=kwargs.get('redirect_uri', ''),
            scope=kwargs.get('scope', ''),
            user_id=user.id,
        )

        with flask.current_app.db.session as session:
            session.add(code)
            session.commit()

        return code.code

    def parse_authorization_code(self, code, client):
        with flask.current_app.db.session as session:
            code = (
                session.query(AuthorizationCode)
                .filter_by(code=code, client_id=client.client_id)
                .first()
            )
        if not code or code.is_expired():
            return None
        return code

    def delete_authorization_code(self, authorization_code):
        with flask.current_app.db.session as session:
            session.delete(authorization_code)
            session.commit()

    def create_access_token(self, token, client, authorization_code):
        pass

    def authenticate_client(self):
        """Parse the authenticated client.

        For example, the client makes the following HTTP request using TLS:

        .. code-block:: http

            POST /token HTTP/1.1
            Host: server.example.com
            Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
            Content-Type: application/x-www-form-urlencoded

            grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
            &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb

        To authenticate client with other means, re-implement this method in
        subclass.

        :return: client
        """
        client_params = self.parse_basic_auth_header()
        if client_params:
            # authenticate the client if client authentication is included
            client_id, client_secret = client_params
            client = self.get_and_validate_client(client_id)
            # Client secrets are stored as hash.
            hashed = client.client_secret
            if bcrypt.hashpw(client_secret, hashed) != hashed:
                raise InvalidClientError(uri=self.uri)

            return client

        # require client authentication for confidential clients or for any
        # client that was issued client credentials (or with other
        # authentication requirements)
        client_id = self.params.get('client_id')
        client = self.get_and_validate_client(client_id)
        if client.check_client_type('confidential') or client.client_secret:
            raise UnauthorizedClientError(uri=self.uri)

        return client

    def create_authorization_response(self, grant_user):
        """
        If the resource owner grants the access request, the authorization
        server issues an authorization code and delivers it to the client by
        adding the following parameters to the query component of the
        redirection URI using the "application/x-www-form-urlencoded" format.
        Per `Section 4.1.2`_.

        code
            REQUIRED.  The authorization code generated by the
            authorization server. The authorization code MUST expire
            shortly after it is issued to mitigate the risk of leaks. A
            maximum authorization code lifetime of 10 minutes is
            RECOMMENDED. The client MUST NOT use the authorization code
            more than once. If an authorization code is used more than
            once, the authorization server MUST deny the request and SHOULD
            revoke (when possible) all tokens previously issued based on
            that authorization code.  The authorization code is bound to
            the client identifier and redirection URI.
        state
            REQUIRED if the "state" parameter was present in the client
            authorization request.  The exact value received from the
            client.

        For example, the authorization server redirects the user-agent by
        sending the following HTTP response.

        .. code-block:: http

            HTTP/1.1 302 Found
            Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
                   &state=xyz

        .. _`Section 4.1.2`: http://tools.ietf.org/html/rfc6749#section-4.1.2

        :param grant_user: pass user model if resource owner granted the
            request, otherwise pass None.
        :returns: (status_code, body, headers)
        """
        if grant_user:
            # ``self.params`` is a werkzeug ``ImmutableMultiDict`` which will
            # cast its values into lists when implicitly to a dictionary (as
            # with the ** syntax), so first turn it into a normal dictionary.
            code = self.create_authorization_code(
                self.client, grant_user, **self.params.to_dict()
            )
            params = [('code', code)]
            if self.state:
                params.append(('state', self.state))
        else:
            error = AccessDeniedError(state=self.state, uri=self.uri)
            params = error.get_body()

        uri = add_params_to_uri(self.redirect_uri, params)
        headers = [('Location', uri)]
        return 302, '', headers
